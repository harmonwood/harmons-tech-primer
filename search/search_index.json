{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Harmon's Tech Primer This is a place for me to put my own simplified Cheat Sheets and common files pre-customized for my common use cases. Also reminders for myself of how I have done something in the past.","title":"Harmon's Tech Primer"},{"location":"#harmons-tech-primer","text":"This is a place for me to put my own simplified Cheat Sheets and common files pre-customized for my common use cases. Also reminders for myself of how I have done something in the past.","title":"Harmon's Tech Primer"},{"location":"documention/","text":"Getting Started Mkdocs is currently my favorite documentation medium. It is lightweight, easy to setup, and the Material theme just hit's all the checkmarks out of the box. Docasourus is a close second. Diagrams When it comes to diagrams there is no one size fits all... Yet. Note As much as Mermaid fits all of my philosophy points it's just not ready for prime time. So I seattle for a combination of structurizr and Diagrams.net. Diagram Philosophy I am a believer in diagrams as code. In a programming environment with many developers it is important that even a new programer on a project feels empowered to update all aspects of the documentation. Diagrams as code gives them that power in two ways. There is no need to hunt down original diagrams to modify, or install/learn a new program. Vi/Emacs will do just fine ;) A simple pull request will allow for developers with more domain knowledge to accurately proof these changes. This makes proposing documentation changes to diagrams zero risk. C4 Architecture Model (Structurizr) Site: C4 Model DL: Structurizr This model gave birth to a Domain language that treats an application architecture like a zoom-able map with separate context views. The cons to this right now is imbedding this into other documentation systems like mkdocs is cumbersome at best. Mermaid Site: Mermaid Mermaid is a js renderer that takes mkdown code and converts it into a diagram. There is a plugin for MkDocs Material already and it also supports basic Structurizr, Controlling object placement is problematic and sometimes down right ugly or unreadable. Structurizr support is limited and artifacts are to small to ready comfortably. Diagrams.net (draw.io) Site: diagrams.net It can be pretty and you can imbed the original diagram in a PNG file so that there is no need to hunt for the original file. The artifact is both the image and the original.","title":"Getting Started"},{"location":"documention/#getting-started","text":"Mkdocs is currently my favorite documentation medium. It is lightweight, easy to setup, and the Material theme just hit's all the checkmarks out of the box. Docasourus is a close second.","title":"Getting Started"},{"location":"documention/#diagrams","text":"When it comes to diagrams there is no one size fits all... Yet. Note As much as Mermaid fits all of my philosophy points it's just not ready for prime time. So I seattle for a combination of structurizr and Diagrams.net.","title":"Diagrams"},{"location":"documention/#diagram-philosophy","text":"I am a believer in diagrams as code. In a programming environment with many developers it is important that even a new programer on a project feels empowered to update all aspects of the documentation. Diagrams as code gives them that power in two ways. There is no need to hunt down original diagrams to modify, or install/learn a new program. Vi/Emacs will do just fine ;) A simple pull request will allow for developers with more domain knowledge to accurately proof these changes. This makes proposing documentation changes to diagrams zero risk.","title":"Diagram Philosophy"},{"location":"documention/#c4-architecture-model-structurizr","text":"Site: C4 Model DL: Structurizr This model gave birth to a Domain language that treats an application architecture like a zoom-able map with separate context views. The cons to this right now is imbedding this into other documentation systems like mkdocs is cumbersome at best.","title":"C4 Architecture Model (Structurizr)"},{"location":"documention/#mermaid","text":"Site: Mermaid Mermaid is a js renderer that takes mkdown code and converts it into a diagram. There is a plugin for MkDocs Material already and it also supports basic Structurizr, Controlling object placement is problematic and sometimes down right ugly or unreadable. Structurizr support is limited and artifacts are to small to ready comfortably.","title":"Mermaid"},{"location":"documention/#diagramsnet-drawio","text":"Site: diagrams.net It can be pretty and you can imbed the original diagram in a PNG file so that there is no need to hunt for the original file. The artifact is both the image and the original.","title":"Diagrams.net (draw.io)"},{"location":"documention/drawio/","text":"Diagrams.net (Draw.io) Diagrams.net is my currently goto choice until Mermaid gets up to speed with the ability to control more of the output. The best feature it has is it's ability to embed it's core data in an image itself leaving no room to go hunt for the source material when updating the docs. Check it out yourself by download this image and opening it in Diagrams.net","title":"Diagrams.net (Draw.io)"},{"location":"documention/drawio/#diagramsnet-drawio","text":"Diagrams.net is my currently goto choice until Mermaid gets up to speed with the ability to control more of the output. The best feature it has is it's ability to embed it's core data in an image itself leaving no room to go hunt for the source material when updating the docs. Check it out yourself by download this image and opening it in Diagrams.net","title":"Diagrams.net (Draw.io)"},{"location":"documention/mkdocs/","text":"MkDocs Links MkDocs MkDocs Material MkDocs Material Reference Installation pip install mkdocs I don't bother with anything else as I always use a docker container for MkDocs. Note: If you are using mkdocs gh-deploy you will need to install the \"ADD_MODULES\" locally as well to get gh-deploy to work. Docker Compose docker-compose.yml version : '3.9' services : primer : image : polinux/mkdocs environment : LIVE_RELOAD_SUPPORT : 'true' ADD_MODULES : 'mkdocs-git-revision-date-localized-plugin mkdocs-material pymdown-extensions pygments' FAST_MODE : 'true' DOCS_DIRECTORY : '/mkdocs' UPDATE_INTERVAL : 15 AUTO_UPDATE : 'true' ports : - 8000:8000 volumes : - ./:/mkdocs This will mount the current directory as /mkdocs in the container and run MkDocs in fast mode with live reload support. The project directory must have a mkdocs.yml file in it and a docs directory with at least an index.md file in it. mkdocs.yml mkdocs.yml site_name : Harmon's Tech Primer theme : name : material palette : - scheme : slate primary : black accent : blue toggle : icon : material/brightness-4 name : Switch to light mode - scheme : default primary : black accent : blue toggle : icon : material/brightness-7 name : Switch to dark mode features : - content.code.copy - content.code.select - content.code.annotate markdown_extensions : - pymdownx.highlight : anchor_linenums : true use_pygments : true auto_title : false line_spans : __span pygments_lang_class : true - admonition - pymdownx.details - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_code_format This file has Light and Dark mode support as well as Mermaid support. It also has code highlighting support. and Copy and Select support for code blocks. Deploying to GitHub Pages mkdocs gh-deploy This command will create a special branch gh-pages a nd push the site to it. You can then go to the settings for the repo and set the GitHub Pages source to the gh-pages branch.","title":"MkDocs"},{"location":"documention/mkdocs/#mkdocs","text":"","title":"MkDocs"},{"location":"documention/mkdocs/#links","text":"MkDocs MkDocs Material MkDocs Material Reference","title":"Links"},{"location":"documention/mkdocs/#installation","text":"pip install mkdocs I don't bother with anything else as I always use a docker container for MkDocs. Note: If you are using mkdocs gh-deploy you will need to install the \"ADD_MODULES\" locally as well to get gh-deploy to work.","title":"Installation"},{"location":"documention/mkdocs/#docker-compose","text":"docker-compose.yml version : '3.9' services : primer : image : polinux/mkdocs environment : LIVE_RELOAD_SUPPORT : 'true' ADD_MODULES : 'mkdocs-git-revision-date-localized-plugin mkdocs-material pymdown-extensions pygments' FAST_MODE : 'true' DOCS_DIRECTORY : '/mkdocs' UPDATE_INTERVAL : 15 AUTO_UPDATE : 'true' ports : - 8000:8000 volumes : - ./:/mkdocs This will mount the current directory as /mkdocs in the container and run MkDocs in fast mode with live reload support. The project directory must have a mkdocs.yml file in it and a docs directory with at least an index.md file in it.","title":"Docker Compose"},{"location":"documention/mkdocs/#mkdocsyml","text":"mkdocs.yml site_name : Harmon's Tech Primer theme : name : material palette : - scheme : slate primary : black accent : blue toggle : icon : material/brightness-4 name : Switch to light mode - scheme : default primary : black accent : blue toggle : icon : material/brightness-7 name : Switch to dark mode features : - content.code.copy - content.code.select - content.code.annotate markdown_extensions : - pymdownx.highlight : anchor_linenums : true use_pygments : true auto_title : false line_spans : __span pygments_lang_class : true - admonition - pymdownx.details - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:pymdownx.superfences.fence_code_format This file has Light and Dark mode support as well as Mermaid support. It also has code highlighting support. and Copy and Select support for code blocks.","title":"mkdocs.yml"},{"location":"documention/mkdocs/#deploying-to-github-pages","text":"mkdocs gh-deploy This command will create a special branch gh-pages a nd push the site to it. You can then go to the settings for the repo and set the GitHub Pages source to the gh-pages branch.","title":"Deploying to GitHub Pages"},{"location":"git/","text":"Getting Started The fastest way to learn git is through practice and visual experience. I run this game about once a year to to keep up on the little things I don't use often. It's a great way to learn the basics and get a feel for how git works. Learn Git Branching","title":"Getting Started"},{"location":"git/#getting-started","text":"The fastest way to learn git is through practice and visual experience. I run this game about once a year to to keep up on the little things I don't use often. It's a great way to learn the basics and get a feel for how git works. Learn Git Branching","title":"Getting Started"},{"location":"git/folder-as-branch/","text":"Folder as Branch Creating the branch The most simple way to do is is to orphan a branch and then delete it's contents, then checkout the folder from the main branch and push. Note Orphaning a branch is a way to create a branch without a history. It is useful for creating a branch that is not related to the main branch. git checkout --orphan branch_name git rm -rf . Populating and publishing the branch If the folder is checked into the repo git checkout main -- folder_name If the folder is git ignored After removing all the files with git rm -rf . The folder will still have the ignored files and folders in it. Remove all that are not the one you want to publish. Then unpack the folder by coping it's contents into the root of the repo. rm random_file_in_gitignore cp -r folder_name/* . rm -rf folder_name Don't forget to commit and push git add . git commit -m \"Publishing to branch_name\" git push origin branch_name Note If you are deploying to gh-pages with a custom domain you will need a CNAME file in the root of this directory. You can create it with echo \"domain.com\" > CNAME and then commit and push it. Make sure you copy it over every time you publish.","title":"Folder as Branch"},{"location":"git/folder-as-branch/#folder-as-branch","text":"","title":"Folder as Branch"},{"location":"git/folder-as-branch/#creating-the-branch","text":"The most simple way to do is is to orphan a branch and then delete it's contents, then checkout the folder from the main branch and push. Note Orphaning a branch is a way to create a branch without a history. It is useful for creating a branch that is not related to the main branch. git checkout --orphan branch_name git rm -rf .","title":"Creating the branch"},{"location":"git/folder-as-branch/#populating-and-publishing-the-branch","text":"","title":"Populating and publishing the branch"},{"location":"git/folder-as-branch/#if-the-folder-is-checked-into-the-repo","text":"git checkout main -- folder_name","title":"If the folder is checked into the repo"},{"location":"git/folder-as-branch/#if-the-folder-is-git-ignored","text":"After removing all the files with git rm -rf . The folder will still have the ignored files and folders in it. Remove all that are not the one you want to publish. Then unpack the folder by coping it's contents into the root of the repo. rm random_file_in_gitignore cp -r folder_name/* . rm -rf folder_name","title":"If the folder is git ignored"},{"location":"git/folder-as-branch/#dont-forget-to-commit-and-push","text":"git add . git commit -m \"Publishing to branch_name\" git push origin branch_name Note If you are deploying to gh-pages with a custom domain you will need a CNAME file in the root of this directory. You can create it with echo \"domain.com\" > CNAME and then commit and push it. Make sure you copy it over every time you publish.","title":"Don't forget to commit and push"},{"location":"jekyll/","text":"Getting Started Installation and usege Jekyll's documentation is awesome. I almost didn't even write this. However, I did want to add a few things that I found useful. Primarily, deploying to GitHub pages. gem install bundler jekyll jekyll new my-awesome-site cd my-awesome-site bundle exec jekyll serve # => Now browse to http://localhost:4000 Deploying to GitHub Pages The best way to deploy to GitHub pages is to use a branch called gh-pages. This branch will be used to host the site. The master branch will be used to host the source code. This is a common pattern for GitHub pages. There is a gem to do this for jekyll 3.0 but I was unable to get it to work on 4.x so we will have to do it by hand. Because this is a common pattern outside of jekyll I will reference the git documentation instead. Migrating a folder to a branch in git.","title":"Getting Started"},{"location":"jekyll/#getting-started","text":"","title":"Getting Started"},{"location":"jekyll/#installation-and-usege","text":"Jekyll's documentation is awesome. I almost didn't even write this. However, I did want to add a few things that I found useful. Primarily, deploying to GitHub pages. gem install bundler jekyll jekyll new my-awesome-site cd my-awesome-site bundle exec jekyll serve # => Now browse to http://localhost:4000","title":"Installation and usege"},{"location":"jekyll/#deploying-to-github-pages","text":"The best way to deploy to GitHub pages is to use a branch called gh-pages. This branch will be used to host the site. The master branch will be used to host the source code. This is a common pattern for GitHub pages. There is a gem to do this for jekyll 3.0 but I was unable to get it to work on 4.x so we will have to do it by hand. Because this is a common pattern outside of jekyll I will reference the git documentation instead. Migrating a folder to a branch in git.","title":"Deploying to GitHub Pages"},{"location":"python/environments/","text":"Python Environments Install a env manager micromamba/anaconda/etc... Currently only in micromamba I will add tabs as needed. https://mamba.readthedocs.io/en/latest/micromamba-installation.html Create env micromamba create -n <env-name> -f environment.yml Run Env mircomamba activate <env-name> Add package micromamba install <package-name> Parsisting the envirnoment: micromamba env export > environment.yml Lets outo activate/deactivate/install the env when changing directories Add this to the ~/.zshrc file (or adapt to your shell) auto_activate_micromamba_env () { if [[ -f \"environment.yml\" ]] ; then local env_name = $( grep 'name:' environment.yml | awk '{print $2}' ) if [[ ! -z \" $env_name \" ]] ; then # Check if the environment exists if [[ $( micromamba env list | awk '{print $1}' | grep -w \"^ ${ env_name } $ \" ) == \"\" ]] ; then micromamba env create -f environment.yml fi # Activate the environment micromamba activate $env_name fi else # Optionally, deactivate if no environment.yml is found micromamba deactivate fi } # Add the function to the array of precmds like changing directory chpwd_functions +=( \"auto_activate_micromamba_env\" ) # Activate the environment when spawning a new shell auto_activate_micromamba_env Note Python 2.7.18 install on an M2 Mac (osx-arm64) with micromamba micromamba create -n py27 python = 2 .7.18 -c http://repo.continuum.io/pkgs/main/osx-arm64","title":"Python Environments"},{"location":"python/environments/#python-environments","text":"","title":"Python Environments"},{"location":"python/environments/#install-a-env-manager-micromambaanacondaetc","text":"Currently only in micromamba I will add tabs as needed. https://mamba.readthedocs.io/en/latest/micromamba-installation.html","title":"Install a env manager micromamba/anaconda/etc..."},{"location":"python/environments/#create-env","text":"micromamba create -n <env-name> -f environment.yml","title":"Create env"},{"location":"python/environments/#run-env","text":"mircomamba activate <env-name>","title":"Run Env"},{"location":"python/environments/#add-package","text":"micromamba install <package-name>","title":"Add package"},{"location":"python/environments/#parsisting-the-envirnoment","text":"micromamba env export > environment.yml","title":"Parsisting the envirnoment:"},{"location":"python/environments/#lets-outo-activatedeactivateinstall-the-env-when-changing-directories","text":"Add this to the ~/.zshrc file (or adapt to your shell) auto_activate_micromamba_env () { if [[ -f \"environment.yml\" ]] ; then local env_name = $( grep 'name:' environment.yml | awk '{print $2}' ) if [[ ! -z \" $env_name \" ]] ; then # Check if the environment exists if [[ $( micromamba env list | awk '{print $1}' | grep -w \"^ ${ env_name } $ \" ) == \"\" ]] ; then micromamba env create -f environment.yml fi # Activate the environment micromamba activate $env_name fi else # Optionally, deactivate if no environment.yml is found micromamba deactivate fi } # Add the function to the array of precmds like changing directory chpwd_functions +=( \"auto_activate_micromamba_env\" ) # Activate the environment when spawning a new shell auto_activate_micromamba_env Note Python 2.7.18 install on an M2 Mac (osx-arm64) with micromamba micromamba create -n py27 python = 2 .7.18 -c http://repo.continuum.io/pkgs/main/osx-arm64","title":"Lets outo activate/deactivate/install the env when changing directories"},{"location":"python/jupyter/","text":"Jupyter Install jupyter micromamba install jupyter Run jupyter jupyter notebook &","title":"Jupyter"},{"location":"python/jupyter/#jupyter","text":"","title":"Jupyter"},{"location":"python/jupyter/#install-jupyter","text":"micromamba install jupyter","title":"Install jupyter"},{"location":"python/jupyter/#run-jupyter","text":"jupyter notebook &","title":"Run jupyter"},{"location":"ruby/environments/","text":"Ruby Environments Install chruby and ruby-install brew install ruby-install chruby Modify zshrc for binary and auto switching #Add the following to the ~/.bash_profile or ~/.zshrc file: source /opt/homebrew/opt/chruby/share/chruby/chruby.sh #To enable auto-switching of Rubies specified by .ruby-version files, #add the following to ~/.bash_profile or ~/.zshrc: source /opt/homebrew/opt/chruby/share/chruby/auto.sh Install latest Ruby This will install ruby ruby-install --update ruby Now to link it add this to your ~/.zshrc file. Remember to change the home and version. export PATH = \"/Users/<home>/.rubies/ruby-<version>/bin: $PATH \" Start using Ruby in a project Create a .ruby-version file in the root of your project and add the version you want to use. chruby will now automatically switch to the version in the .ruby-version file when you enter the directory. echo \"ruby-3.2.2\" > .ruby-version Install bundler gem install bundler Install gems bundle install","title":"Ruby Environments"},{"location":"ruby/environments/#ruby-environments","text":"","title":"Ruby Environments"},{"location":"ruby/environments/#install-chruby-and-ruby-install","text":"brew install ruby-install chruby","title":"Install chruby and ruby-install"},{"location":"ruby/environments/#modify-zshrc-for-binary-and-auto-switching","text":"#Add the following to the ~/.bash_profile or ~/.zshrc file: source /opt/homebrew/opt/chruby/share/chruby/chruby.sh #To enable auto-switching of Rubies specified by .ruby-version files, #add the following to ~/.bash_profile or ~/.zshrc: source /opt/homebrew/opt/chruby/share/chruby/auto.sh","title":"Modify zshrc for binary and auto switching"},{"location":"ruby/environments/#install-latest-ruby","text":"This will install ruby ruby-install --update ruby Now to link it add this to your ~/.zshrc file. Remember to change the home and version. export PATH = \"/Users/<home>/.rubies/ruby-<version>/bin: $PATH \"","title":"Install latest Ruby"},{"location":"ruby/environments/#start-using-ruby-in-a-project","text":"Create a .ruby-version file in the root of your project and add the version you want to use. chruby will now automatically switch to the version in the .ruby-version file when you enter the directory. echo \"ruby-3.2.2\" > .ruby-version","title":"Start using Ruby in a project"},{"location":"ruby/environments/#install-bundler","text":"gem install bundler","title":"Install bundler"},{"location":"ruby/environments/#install-gems","text":"bundle install","title":"Install gems"},{"location":"ruby/rails/","text":"","title":"Rails"}]}